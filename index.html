<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Canvas鼠标滚轮缩放和拖放</title>
  <style>
    canvas {
      border: solid 1px #000;
      margin: 0px auto;
      display: block;
    }
  </style>
</head>

<body>
  <script src="./scripts/gl-matrix-min.js"></script>
  <canvas id="canvas"></canvas>
  <script>
    class Scene {
      maxScale = 8;
      minScale = 0.4;
      scaleStep = 0.2;
      scale = 1;
      preScale = 1;

      ov = new Float32Array([
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
      ]);

      constructor(id, options = {
        width: 600,
        height: 400
      }) {
        this.canvas = document.querySelector('#' + id)
        this.width = options.width;
        this.height = options.height;
        this.canvas.width = options.width;
        this.canvas.height = options.height;
        this.ctx = this.canvas.getContext('2d');

        this.onMousedown = this.onMousedown.bind(this);
        this.onMousemove = this.onMousemove.bind(this);
        this.onMouseup = this.onMouseup.bind(this);
        this.onMousewheel = this.onMousewheel.bind(this);
        this.canvas.addEventListener('mousewheel', this.onMousewheel);
        this.canvas.addEventListener('mousedown', this.onMousedown);
      }

      onMousewheel(e) {
        e.preventDefault();

        const { clientX, clientY, deltaY } = e;
        const currSacle = 1 + (deltaY < 0 ? 0.1 : -0.1);
        const zoom = Math.max(currSacle > 0 ? currSacle : 1, 0.1);

        console.log('zoom:', zoom);

        const x = clientX * (1 - zoom);
        const y = clientY * (1 - zoom);
        const t = new Float32Array([
          zoom, 0, 0,
          0, zoom, 0,
          x, y, 1,
        ]);
        this.ov = this.refresh(this.ov, t);
        // if (e.wheelDelta > 0) {
        //   // 放大
        //   this.scale = parseFloat((this.scaleStep + this.scale).toFixed(2)); // 解决小数点运算丢失精度的问题
        //   if (this.scale > this.maxScale) {
        //     this.scale = this.maxScale;
        //     return;
        //   }
        // } else {
        //   // 缩小
        //   this.scale = parseFloat((this.scale - this.scaleStep).toFixed(2)); // 解决小数点运算丢失精度的问题
        //   if (this.scale < this.minScale) {
        //     this.scale = this.minScale;
        //     return;
        //   }
        // }

        // this.zoom();
      }

      onMousedown(e) {
        if (e.button === 0) {
          // 鼠标左键
          window.addEventListener('mousemove', this.onMousemove);
          window.addEventListener('mouseup', this.onMouseup);
        }
      }

      onMousemove(e) {
        const {movementX, movementY} = e;
        const t = new Float32Array([
            1, 0, 0,
            0, 1, 0,
            movementX, movementY, 1,
        ]);
        this.ov = this.refresh(this.ov, t);
      }

      onMouseup() {
        window.removeEventListener('mousemove', this.onMousemove);
        window.removeEventListener('mouseup', this.onMouseup);
      }

      refresh(o, t) {
        const out = new Float32Array([
          0, 0, 0,
          0, 0, 0,
          0, 0, 0,
        ]);
        const nv = glMatrix.mat3.multiply(out, t, o);
        // this.ctx.save();
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.canvas.width = this.width;
        this.ctx.transform(nv[0], nv[3], nv[1], nv[4], nv[6], nv[7]);
        this.draw();
        // this.ctx.restore();
        return nv;
      }

      draw() {
        this.ctx.fillStyle = 'red';
        this.ctx.fillRect(0, 0, 50, 50);
      }
    }

    let scene = new Scene('canvas');

    scene.draw();
  </script>
</body>

</html>
